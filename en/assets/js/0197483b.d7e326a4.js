"use strict";(self.webpackChunkdata_structures=self.webpackChunkdata_structures||[]).push([[7397],{8021:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Bienvenida","href":"/Data_Structures/en/docs/intro","docId":"intro","unlisted":false},{"type":"category","label":"Introducci\xf3n a las Estructuras de Datos","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"\xbfQu\xe9 son y para qu\xe9 sirven?","href":"/Data_Structures/en/docs/data_structures_introduction/what_are_they_and_what_are_they_for","docId":"data_structures_introduction/what_are_they_and_what_are_they_for","unlisted":false},{"type":"link","label":"Eficiencia, Espacio y Tiempo","href":"/Data_Structures/en/docs/data_structures_introduction/efficiency_space_and_time","docId":"data_structures_introduction/efficiency_space_and_time","unlisted":false},{"type":"link","label":"Tipos de estructuras: Primitivas y Abstractas","href":"/Data_Structures/en/docs/data_structures_introduction/types_of_structures_primitive_and_abstract","docId":"data_structures_introduction/types_of_structures_primitive_and_abstract","unlisted":false},{"type":"link","label":"TDA (Tipos de Datos Abstractos)","href":"/Data_Structures/en/docs/data_structures_introduction/tda_abstract_data_types","docId":"data_structures_introduction/tda_abstract_data_types","unlisted":false}],"href":"/Data_Structures/en/docs/category/introducci\xf3n-a-las-estructuras-de-datos"},{"type":"category","label":"Arreglos","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Arreglos est\xe1ticos","href":"/Data_Structures/en/docs/arrays/static_arrays","docId":"arrays/static_arrays","unlisted":false},{"type":"link","label":"Arreglos din\xe1micos","href":"/Data_Structures/en/docs/arrays/dynamic_arrays","docId":"arrays/dynamic_arrays","unlisted":false},{"type":"link","label":"Ejercicios propuestos por tema","href":"/Data_Structures/en/docs/arrays/exercises","docId":"arrays/exercises","unlisted":false}],"href":"/Data_Structures/en/docs/category/arreglos"},{"type":"category","label":"An\xe1lisis de Algoritmos","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Notaci\xf3n Big O","href":"/Data_Structures/en/docs/analysis_of_algorithms/big_o_notation","docId":"analysis_of_algorithms/big_o_notation","unlisted":false},{"type":"link","label":"Complejidad temporal y espacial","href":"/Data_Structures/en/docs/analysis_of_algorithms/time_and_space_complexity","docId":"analysis_of_algorithms/time_and_space_complexity","unlisted":false},{"type":"link","label":"Casos mejor, promedio y peor","href":"/Data_Structures/en/docs/analysis_of_algorithms/best_average_and_worst_cases","docId":"analysis_of_algorithms/best_average_and_worst_cases","unlisted":false}],"href":"/Data_Structures/en/docs/category/an\xe1lisis-de-algoritmos"},{"type":"category","label":"Estructuras Lineales y Uso de Nodos","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Nodos y Punteros","href":"/Data_Structures/en/docs/linear_structures_and_use_of_nodes/nodes_and_pointers","docId":"linear_structures_and_use_of_nodes/nodes_and_pointers","unlisted":false},{"type":"link","label":"Lista Enlazada Simple","href":"/Data_Structures/en/docs/linear_structures_and_use_of_nodes/singly_linked_list","docId":"linear_structures_and_use_of_nodes/singly_linked_list","unlisted":false},{"type":"link","label":"Lista Enlazada Doble","href":"/Data_Structures/en/docs/linear_structures_and_use_of_nodes/doubly_linked_list","docId":"linear_structures_and_use_of_nodes/doubly_linked_list","unlisted":false},{"type":"link","label":"Lista Enlazada Circular Simple","href":"/Data_Structures/en/docs/linear_structures_and_use_of_nodes/singly_circular_linked_list","docId":"linear_structures_and_use_of_nodes/singly_circular_linked_list","unlisted":false},{"type":"link","label":"Lista Enlazada Circular Doble","href":"/Data_Structures/en/docs/linear_structures_and_use_of_nodes/doubly_circular_linked_list","docId":"linear_structures_and_use_of_nodes/doubly_circular_linked_list","unlisted":false},{"type":"link","label":"Stack (Pilas): LIFO, implementaci\xf3n con arrays y listas enlazadas","href":"/Data_Structures/en/docs/linear_structures_and_use_of_nodes/stack","docId":"linear_structures_and_use_of_nodes/stack","unlisted":false},{"type":"link","label":"Queue (Colas): FIFO, variantes (colas dobles, de prioridad)","href":"/Data_Structures/en/docs/linear_structures_and_use_of_nodes/queue","docId":"linear_structures_and_use_of_nodes/queue","unlisted":false},{"type":"link","label":"Ejercicios propuestos por tema","href":"/Data_Structures/en/docs/linear_structures_and_use_of_nodes/exercises","docId":"linear_structures_and_use_of_nodes/exercises","unlisted":false}],"href":"/Data_Structures/en/docs/category/estructuras-lineales-y-uso-de-nodos"},{"type":"category","label":"Algoritmos de Ordenamiento","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Fundamentos del ordenamiento: estabilidad, adaptabilidad y comparaciones","href":"/Data_Structures/en/docs/sorting_algorithms/sorting_fundamentals","docId":"sorting_algorithms/sorting_fundamentals","unlisted":false},{"type":"link","label":"Bubble Sort","href":"/Data_Structures/en/docs/sorting_algorithms/bubble_sort","docId":"sorting_algorithms/bubble_sort","unlisted":false},{"type":"link","label":"Selection Sort","href":"/Data_Structures/en/docs/sorting_algorithms/selection_sort","docId":"sorting_algorithms/selection_sort","unlisted":false},{"type":"link","label":"Insertion Sort","href":"/Data_Structures/en/docs/sorting_algorithms/insertion_sort","docId":"sorting_algorithms/insertion_sort","unlisted":false},{"type":"link","label":"Merge Sort","href":"/Data_Structures/en/docs/sorting_algorithms/merge_sort","docId":"sorting_algorithms/merge_sort","unlisted":false},{"type":"link","label":"Quick Sort","href":"/Data_Structures/en/docs/sorting_algorithms/quick_sort","docId":"sorting_algorithms/quick_sort","unlisted":false},{"type":"link","label":"Heap Sort","href":"/Data_Structures/en/docs/sorting_algorithms/heap_sort","docId":"sorting_algorithms/heap_sort","unlisted":false},{"type":"link","label":"Counting Sort","href":"/Data_Structures/en/docs/sorting_algorithms/counting_sort","docId":"sorting_algorithms/counting_sort","unlisted":false},{"type":"link","label":"Radix Sort","href":"/Data_Structures/en/docs/sorting_algorithms/radix_sort","docId":"sorting_algorithms/radix_sort","unlisted":false},{"type":"link","label":"Bucket Sort","href":"/Data_Structures/en/docs/sorting_algorithms/bucket_sort","docId":"sorting_algorithms/bucket_sort","unlisted":false}],"href":"/Data_Structures/en/docs/category/algoritmos-de-ordenamiento"}]},"docs":{"analysis_of_algorithms/best_average_and_worst_cases":{"id":"analysis_of_algorithms/best_average_and_worst_cases","title":"Casos mejor, promedio y peor","description":"El an\xe1lisis de algoritmos no solo se enfoca en el crecimiento de su tiempo de ejecuci\xf3n o uso de memoria (Big O y complejidad temporal/espacial), sino tambi\xe9n en c\xf3mo se comportan en diferentes escenarios de entrada. Por eso se utilizan los conceptos de:","sidebar":"tutorialSidebar"},"analysis_of_algorithms/big_o_notation":{"id":"analysis_of_algorithms/big_o_notation","title":"Notaci\xf3n Big O","description":"La notaci\xf3n Big O (o \\"O grande\\") es una herramienta matem\xe1tica usada para describir el comportamiento asint\xf3tico de un algoritmo, es decir, c\xf3mo crece el tiempo de ejecuci\xf3n o el uso de memoria en funci\xf3n del tama\xf1o de la entrada n. Esta notaci\xf3n es esencial en el an\xe1lisis de algoritmos porque permite comparar su eficiencia de forma independiente al hardware o lenguaje utilizado (Cormen et al., 2022).","sidebar":"tutorialSidebar"},"analysis_of_algorithms/time_and_space_complexity":{"id":"analysis_of_algorithms/time_and_space_complexity","title":"Complejidad temporal y espacial","description":"La complejidad temporal y espacial son m\xe9tricas fundamentales en el an\xe1lisis de algoritmos. Permiten evaluar el rendimiento (tiempo) y el uso de recursos (memoria) de un programa. Estas m\xe9tricas son independientes del hardware y se expresan generalmente en funci\xf3n del tama\xf1o de la entrada n.","sidebar":"tutorialSidebar"},"arrays/dynamic_arrays":{"id":"arrays/dynamic_arrays","title":"Arreglos din\xe1micos","description":"Un arreglo din\xe1mico es una estructura de datos lineal que, a diferencia de un arreglo est\xe1tico, puede crecer o reducirse durante la ejecuci\xf3n. Permite agregar elementos sin conocer de antemano cu\xe1ntos ser\xe1n, lo que lo hace muy \xfatil en programaci\xf3n moderna.","sidebar":"tutorialSidebar"},"arrays/exercises":{"id":"arrays/exercises","title":"Ejercicios propuestos por tema","description":"Arreglos est\xe1ticos","sidebar":"tutorialSidebar"},"arrays/static_arrays":{"id":"arrays/static_arrays","title":"Arreglos est\xe1ticos","description":"Un arreglo est\xe1tico (tambi\xe9n llamado array de tama\xf1o fijo) es una estructura de datos lineal que almacena una colecci\xf3n de elementos del mismo tipo en posiciones de memoria contiguas. Su tama\xf1o se define en el momento de la creaci\xf3n y no puede cambiar durante la ejecuci\xf3n del programa.","sidebar":"tutorialSidebar"},"data_structures_introduction/efficiency_space_and_time":{"id":"data_structures_introduction/efficiency_space_and_time","title":"Eficiencia, Espacio y Tiempo","description":"Cuando hablamos de estructuras de datos o algoritmos, eficiencia se refiere a qu\xe9 tan bien utilizan los recursos computacionales (como tiempo y memoria). Evaluar la eficiencia nos permite tomar decisiones informadas sobre qu\xe9 estructura o algoritmo es el m\xe1s adecuado para una tarea espec\xedfica.","sidebar":"tutorialSidebar"},"data_structures_introduction/tda_abstract_data_types":{"id":"data_structures_introduction/tda_abstract_data_types","title":"TDA (Tipos de Datos Abstractos)","description":"Un Tipo de Dato Abstracto (TDA) es un modelo matem\xe1tico o l\xf3gico que define un comportamiento o conjunto de operaciones que se pueden realizar sobre un conjunto de datos, sin especificar su implementaci\xf3n interna.","sidebar":"tutorialSidebar"},"data_structures_introduction/types_of_structures_primitive_and_abstract":{"id":"data_structures_introduction/types_of_structures_primitive_and_abstract","title":"Tipos de estructuras: Primitivas y Abstractas","description":"Las estructuras de datos pueden clasificarse en dos grandes grupos:","sidebar":"tutorialSidebar"},"data_structures_introduction/what_are_they_and_what_are_they_for":{"id":"data_structures_introduction/what_are_they_and_what_are_they_for","title":"\xbfQu\xe9 son y para qu\xe9 sirven?","description":"Las estructuras de datos son formas organizadas de almacenar, administrar y manipular informaci\xf3n en un programa inform\xe1tico. Permiten que los datos sean utilizados de manera eficiente, dependiendo del tipo de operaci\xf3n que se necesite realizar: b\xfasqueda, inserci\xf3n, eliminaci\xf3n, ordenamiento, entre otras.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Bienvenida","description":"\\"El conocimiento no se guarda, se comparte.\\" Comunidad de c\xf3digo abierto","sidebar":"tutorialSidebar"},"linear_structures_and_use_of_nodes/doubly_circular_linked_list":{"id":"linear_structures_and_use_of_nodes/doubly_circular_linked_list","title":"Lista Enlazada Circular Doble","description":"Una lista enlazada circular doble es una estructura de datos lineal y din\xe1mica que combina las propiedades de:","sidebar":"tutorialSidebar"},"linear_structures_and_use_of_nodes/doubly_linked_list":{"id":"linear_structures_and_use_of_nodes/doubly_linked_list","title":"Lista Enlazada Doble","description":"Una lista enlazada doble es una estructura de datos lineal que extiende el concepto de la lista enlazada simple. Cada nodo contiene referencias tanto al siguiente nodo como al anterior, permitiendo un recorrido en ambas direcciones.","sidebar":"tutorialSidebar"},"linear_structures_and_use_of_nodes/exercises":{"id":"linear_structures_and_use_of_nodes/exercises","title":"Ejercicios propuestos por tema","description":"Nodos y Punteros","sidebar":"tutorialSidebar"},"linear_structures_and_use_of_nodes/nodes_and_pointers":{"id":"linear_structures_and_use_of_nodes/nodes_and_pointers","title":"Nodos y Punteros","description":"En estructuras de datos como listas enlazadas, \xe1rboles o grafos, los conceptos de nodos y punteros son fundamentales:","sidebar":"tutorialSidebar"},"linear_structures_and_use_of_nodes/queue":{"id":"linear_structures_and_use_of_nodes/queue","title":"Queue (Colas): FIFO, variantes (colas dobles, de prioridad)","description":"Una cola (Queue) es una estructura de datos lineal que sigue el principio FIFO (First In, First Out), es decir, el primer elemento en entrar es el primero en salir.","sidebar":"tutorialSidebar"},"linear_structures_and_use_of_nodes/singly_circular_linked_list":{"id":"linear_structures_and_use_of_nodes/singly_circular_linked_list","title":"Lista Enlazada Circular Simple","description":"Una lista enlazada circular simple es una variaci\xf3n de la lista enlazada simple en la que el \xfaltimo nodo no apunta a null, sino que enlaza nuevamente al primer nodo (head), formando un ciclo.","sidebar":"tutorialSidebar"},"linear_structures_and_use_of_nodes/singly_linked_list":{"id":"linear_structures_and_use_of_nodes/singly_linked_list","title":"Lista Enlazada Simple","description":"Una lista enlazada simple (Singly Linked List) es una estructura de datos lineal y din\xe1mica en la que los elementos (llamados nodos) se enlazan uno tras otro mediante referencias. A diferencia de los arreglos o vectores, sus elementos no se almacenan de forma contigua en memoria, sino que cada nodo guarda la ubicaci\xf3n del siguiente.","sidebar":"tutorialSidebar"},"linear_structures_and_use_of_nodes/stack":{"id":"linear_structures_and_use_of_nodes/stack","title":"Stack (Pilas): LIFO, implementaci\xf3n con arrays y listas enlazadas","description":"Una pila (Stack) es una estructura de datos lineal que sigue el principio LIFO (Last In, First Out), es decir, el \xfaltimo elemento en entrar es el primero en salir.","sidebar":"tutorialSidebar"},"sorting_algorithms/bubble_sort":{"id":"sorting_algorithms/bubble_sort","title":"Bubble Sort","description":"Bubble Sort es uno de los algoritmos de ordenamiento m\xe1s sencillos. Su nombre proviene del hecho de que los elementos \\"grandes\\" van \\"burbujeando\\" hacia el final de la lista en cada pasada.","sidebar":"tutorialSidebar"},"sorting_algorithms/bucket_sort":{"id":"sorting_algorithms/bucket_sort","title":"Bucket Sort","description":"","sidebar":"tutorialSidebar"},"sorting_algorithms/counting_sort":{"id":"sorting_algorithms/counting_sort","title":"Counting Sort","description":"Counting Sort es un algoritmo de ordenamiento no basado en comparaci\xf3n, dise\xf1ado para ordenar enteros en un rango conocido. Se basa en contar la cantidad de ocurrencias de cada valor, y luego usar esta informaci\xf3n para reconstruir el arreglo ordenado.","sidebar":"tutorialSidebar"},"sorting_algorithms/heap_sort":{"id":"sorting_algorithms/heap_sort","title":"Heap Sort","description":"Heap Sort es un algoritmo de ordenamiento basado en la estructura de datos heap binario (mont\xedculo). Utiliza un Max-Heap (o Min-Heap, seg\xfan el orden requerido) para organizar los datos y ordenarlos de manera eficiente.","sidebar":"tutorialSidebar"},"sorting_algorithms/insertion_sort":{"id":"sorting_algorithms/insertion_sort","title":"Insertion Sort","description":"Insertion Sort es un algoritmo de ordenamiento simple y eficiente para listas peque\xf1as o parcialmente ordenadas. Su funcionamiento se asemeja a la forma en que una persona organiza cartas en su mano: toma un elemento y lo coloca en su posici\xf3n correcta respecto a los que ya est\xe1n ordenados.","sidebar":"tutorialSidebar"},"sorting_algorithms/merge_sort":{"id":"sorting_algorithms/merge_sort","title":"Merge Sort","description":"Merge Sort es un algoritmo de ordenamiento eficiente basado en el paradigma Divide y Vencer\xe1s (Divide and Conquer). Se divide recursivamente la lista en mitades hasta obtener sublistas de un solo elemento, y luego se fusionan en orden ascendente.","sidebar":"tutorialSidebar"},"sorting_algorithms/quick_sort":{"id":"sorting_algorithms/quick_sort","title":"Quick Sort","description":"Quick Sort es un algoritmo de ordenamiento eficiente basado en el paradigma de Divide y Vencer\xe1s, como Merge Sort, pero con una ventaja significativa: puede ejecutarse en memoria sin espacio extra (es in-place).","sidebar":"tutorialSidebar"},"sorting_algorithms/radix_sort":{"id":"sorting_algorithms/radix_sort","title":"Radix Sort","description":"","sidebar":"tutorialSidebar"},"sorting_algorithms/selection_sort":{"id":"sorting_algorithms/selection_sort","title":"Selection Sort","description":"Selection Sort es un algoritmo de ordenamiento simple que trabaja seleccionando el elemento m\xe1s peque\xf1o (o m\xe1s grande, seg\xfan el criterio) en cada iteraci\xf3n y coloc\xe1ndolo en su posici\xf3n correcta.","sidebar":"tutorialSidebar"},"sorting_algorithms/sorting_fundamentals":{"id":"sorting_algorithms/sorting_fundamentals","title":"Fundamentos del ordenamiento: estabilidad, adaptabilidad y comparaciones","description":"El ordenamiento (sorting) es el proceso de organizar los elementos de una colecci\xf3n (arreglo, lista, etc.) de acuerdo con un criterio de comparaci\xf3n (por ejemplo, de menor a mayor). Los algoritmos de ordenamiento se eval\xfaan seg\xfan varias propiedades fundamentales:","sidebar":"tutorialSidebar"}}}}')}}]);