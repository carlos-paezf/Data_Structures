"use strict";(globalThis.webpackChunkdata_structures=globalThis.webpackChunkdata_structures||[]).push([[3642],{1470:(e,n,r)=>{r.d(n,{A:()=>N});var i=r(6540),t=r(4164),s=r(3104),o=r(6347),d=r(205),l=r(7485),a=r(1682),c=r(679);function u(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:r}=e;return(0,i.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:r,default:i}})=>({value:e,label:n,attributes:r,default:i}))}(r);return function(e){const n=(0,a.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,r])}function f({value:e,tabValues:n}){return n.some(n=>n.value===e)}function y({queryString:e=!1,groupId:n}){const r=(0,o.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(t),(0,i.useCallback)(e=>{if(!t)return;const n=new URLSearchParams(r.location.search);n.set(t,e),r.replace({...r.location,search:n.toString()})},[t,r])]}function p(e){const{defaultValue:n,queryString:r=!1,groupId:t}=e,s=h(e),[o,l]=(0,i.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!f({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const r=n.find(e=>e.default)??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:s})),[a,u]=y({queryString:r,groupId:t}),[p,x]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[r,t]=(0,c.Dv)(n);return[r,(0,i.useCallback)(e=>{n&&t.set(e)},[n,t])]}({groupId:t}),k=(()=>{const e=a??p;return f({value:e,tabValues:s})?e:null})();(0,d.A)(()=>{k&&l(k)},[k]);return{selectedValue:o,selectValue:(0,i.useCallback)(e=>{if(!f({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),x(e)},[u,x,s]),tabValues:s}}var x=r(2303);const k={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var m=r(4848);function b({className:e,block:n,selectedValue:r,selectValue:i,tabValues:o}){const d=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),a=e=>{const n=e.currentTarget,t=d.indexOf(n),s=o[t].value;s!==r&&(l(n),i(s))},c=e=>{let n=null;switch(e.key){case"Enter":a(e);break;case"ArrowRight":{const r=d.indexOf(e.currentTarget)+1;n=d[r]??d[0];break}case"ArrowLeft":{const r=d.indexOf(e.currentTarget)-1;n=d[r]??d[d.length-1];break}}n?.focus()};return(0,m.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":n},e),children:o.map(({value:e,label:n,attributes:i})=>(0,m.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{d.push(e)},onKeyDown:c,onClick:a,...i,className:(0,t.A)("tabs__item",k.tabItem,i?.className,{"tabs__item--active":r===e}),children:n??e},e))})}function g({lazy:e,children:n,selectedValue:r}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===r);return e?(0,i.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,m.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==r}))})}function v(e){const n=p(e);return(0,m.jsxs)("div",{className:(0,t.A)("tabs-container",k.tabList),children:[(0,m.jsx)(b,{...n,...e}),(0,m.jsx)(g,{...n,...e})]})}function N(e){const n=(0,x.A)();return(0,m.jsx)(v,{...e,children:u(e.children)},String(n))}},3587:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>f,frontMatter:()=>l,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"nolinear_structures_trees/b_b+_tree","title":"\xc1rboles B y B+","description":"\xbfQu\xe9 es un \xc1rbol B?","source":"@site/docs/06_nolinear_structures_trees/06_b_b+_tree.md","sourceDirName":"06_nolinear_structures_trees","slug":"/nolinear_structures_trees/b_b+_tree","permalink":"/Data_Structures/docs/nolinear_structures_trees/b_b+_tree","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/06_nolinear_structures_trees/06_b_b+_tree.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar-position":6},"sidebar":"tutorialSidebar","previous":{"title":"\xc1rboles autobalanceados AVL","permalink":"/Data_Structures/docs/nolinear_structures_trees/avl_trees"}}');var t=r(4848),s=r(8453),o=r(1470),d=r(9365);const l={"sidebar-position":6},a="\xc1rboles B y B+",c={},u=[{value:"\xbfQu\xe9 es un \xc1rbol B?",id:"qu\xe9-es-un-\xe1rbol-b",level:2},{value:"Caracter\xedsticas principales de un \xc1rbol B (orden m)",id:"caracter\xedsticas-principales-de-un-\xe1rbol-b-orden-m",level:2},{value:"\xbfQu\xe9 es un \xc1rbol B+?",id:"qu\xe9-es-un-\xe1rbol-b-1",level:2},{value:"Diferencia entre \xc1rbol B y \xc1rbol B+",id:"diferencia-entre-\xe1rbol-b-y-\xe1rbol-b",level:2},{value:"Estructura de un \xe1rbol B (orden 3)",id:"estructura-de-un-\xe1rbol-b-orden-3",level:2},{value:"Estructura de un \xe1rbol B+ (orden 3)",id:"estructura-de-un-\xe1rbol-b-orden-3-1",level:2},{value:"Ejemplo t\xe9cnico B Tree",id:"ejemplo-t\xe9cnico-b-tree",level:2},{value:"Ejemplo t\xe9cnico B+ Tree",id:"ejemplo-t\xe9cnico-b-tree-1",level:2},{value:"Aplicaciones pr\xe1cticas",id:"aplicaciones-pr\xe1cticas",level:2},{value:"Referencias",id:"referencias",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"\xe1rboles-b-y-b",children:"\xc1rboles B y B+"})}),"\n",(0,t.jsx)(n.h2,{id:"qu\xe9-es-un-\xe1rbol-b",children:"\xbfQu\xe9 es un \xc1rbol B?"}),"\n",(0,t.jsxs)(n.p,{children:["Un ",(0,t.jsx)(n.strong,{children:"\xc1rbol B"})," (B-Tree) es una estructura de datos auto-balanceada de b\xfasqueda generalizada, dise\xf1ada para trabajar eficientemente con sistemas de almacenamiento secundario (como discos duros o bases de datos). Fue desarrollado por Bayer y McCreight en 1972."]}),"\n",(0,t.jsx)(n.p,{children:"Se usa ampliamente en sistemas de archivos, gestores de bases de datos y sistemas indexados, donde las operaciones de inserci\xf3n, eliminaci\xf3n y b\xfasqueda deben mantenerse en tiempo logar\xedtmico incluso con grandes vol\xfamenes de datos."}),"\n",(0,t.jsx)(n.h2,{id:"caracter\xedsticas-principales-de-un-\xe1rbol-b-orden-m",children:"Caracter\xedsticas principales de un \xc1rbol B (orden m)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Cada nodo interno puede tener como m\xe1ximo ",(0,t.jsx)(n.code,{children:"m"})," hijos."]}),"\n",(0,t.jsxs)(n.li,{children:["Cada nodo (excepto la ra\xedz) tiene al menos ",(0,t.jsx)(n.code,{children:"[m\u20442]"})," hijos."]}),"\n",(0,t.jsxs)(n.li,{children:["Cada nodo contiene ",(0,t.jsx)(n.code,{children:"k"})," ",(0,t.jsx)(n.strong,{children:"claves"}),", donde ",(0,t.jsx)(n.code,{children:"\u2308m\u20442\u2309\u22121 \u2264 k \u2264 m\u22121"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Todos los ",(0,t.jsx)(n.strong,{children:"datos est\xe1n distribuidos en nodos internos y hojas"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Las ",(0,t.jsx)(n.strong,{children:"hojas est\xe1n al mismo nivel"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["El \xe1rbol se ",(0,t.jsx)(n.strong,{children:"rebalancea mediante divisiones de nodos"})," cuando se insertan elementos."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"qu\xe9-es-un-\xe1rbol-b-1",children:"\xbfQu\xe9 es un \xc1rbol B+?"}),"\n",(0,t.jsxs)(n.p,{children:["Un ",(0,t.jsx)(n.strong,{children:"\xc1rbol B+"})," (B+ Tree) es una variaci\xf3n del \xc1rbol B con diferencias clave:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Solo las hojas almacenan los datos"})," reales."]}),"\n",(0,t.jsxs)(n.li,{children:["Los ",(0,t.jsx)(n.strong,{children:"nodos internos solo contienen claves de gu\xeda"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Las ",(0,t.jsx)(n.strong,{children:"hojas est\xe1n enlazadas secuencialmente"}),", facilitando recorridos en orden."]}),"\n",(0,t.jsxs)(n.li,{children:["Ofrece ",(0,t.jsx)(n.strong,{children:"mejor rendimiento en b\xfasquedas y rangos"})," de valores."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"diferencia-entre-\xe1rbol-b-y-\xe1rbol-b",children:"Diferencia entre \xc1rbol B y \xc1rbol B+"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Caracter\xedstica"}),(0,t.jsx)(n.th,{children:"\xc1rbol B"}),(0,t.jsx)(n.th,{children:"\xc1rbol B+"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Almacenamiento de datos"}),(0,t.jsx)(n.td,{children:"Nodos internos y hojas"}),(0,t.jsx)(n.td,{children:"Solo en hojas"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Recorridos secuenciales"}),(0,t.jsx)(n.td,{children:"No optimizados"}),(0,t.jsx)(n.td,{children:"Eficientes (listas enlazadas)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Nodos hoja enlazados"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"S\xed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Claves en nodos internos"}),(0,t.jsx)(n.td,{children:"Pueden contener datos"}),(0,t.jsx)(n.td,{children:"Solo claves"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"estructura-de-un-\xe1rbol-b-orden-3",children:"Estructura de un \xe1rbol B (orden 3)"}),"\n",(0,t.jsx)(n.mermaid,{value:'graph TD\n    R["Ra\xedz<br/>15"] --\x3e A["7 | 10"]\n    R --\x3e B["22"]\n    A --\x3e C["5"]\n    A --\x3e D["8 | 9"]\n    A --\x3e E["12"]\n    B --\x3e F["20"]\n    B --\x3e G["30"]'}),"\n",(0,t.jsx)(n.h2,{id:"estructura-de-un-\xe1rbol-b-orden-3-1",children:"Estructura de un \xe1rbol B+ (orden 3)"}),"\n",(0,t.jsx)(n.mermaid,{value:'graph TD\n  %% Nodo ra\xedz\n  A["Ra\xedz<br/>10 | 20"] \n  I1["Clave 10"]\n  I2["Clave 20"]\n  A -.-> I1\n  A -.-> I2\n  I1 --\x3e B["1 | 5 | 9"]\n  I1 --\x3e C["11 | 15 | 18"]\n  I2 --\x3e D["21 | 25 | 30"]\n\n  %% Subgrafo de hojas\n  subgraph Hojas\n    direction LR\n    E["1"] --\x3e F["5"] --\x3e G["9"] \n    H["11"] --\x3e I["15"] --\x3e J["18"] \n    K["21"] --\x3e L["25"] --\x3e M["30"]\n  end\n\n  %% Enlaces de nodos internos a hojas\n  B --\x3e E\n  B --\x3e F\n  B --\x3e G\n  C --\x3e H\n  C --\x3e I\n  C --\x3e J\n  D --\x3e K\n  D --\x3e L\n  D --\x3e M\n\n  %% Enlaces entre hojas\n  E -.-> F\n  F -.-> G\n  G -.-> H\n  H -.-> I\n  I -.-> J\n  J -.-> K\n  K -.-> L\n  L -.-> M'}),"\n",(0,t.jsx)(n.h2,{id:"ejemplo-t\xe9cnico-b-tree",children:"Ejemplo t\xe9cnico B Tree"}),"\n","\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(d.A,{value:"java",label:"Paradigma: Orientado a Objetos",children:(0,t.jsxs)(o.A,{children:[(0,t.jsxs)(d.A,{value:"code",label:"C\xf3digo Java Ejemplo",children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'showLineNumbers title="BTreeNode.java"',children:'public class BTreeNode {\n    int[] keys;\n    int t; // Grado m\xednimo\n    BTreeNode[] children;\n    int numKeys;\n    boolean isLeaf;\n\n    public BTreeNode(int t, boolean isLeaf) {\n        this.t = t;\n        this.isLeaf = isLeaf;\n        this.keys = new int[2 * t - 1];\n        this.children = new BTreeNode[2 * t];\n        this.numKeys = 0;\n    }\n\n    public void traverse() {\n        for (int i = 0; i < numKeys; i++) {\n            if (!isLeaf) children[i].traverse();\n            System.out.print(keys[i] + " ");\n        }\n        if (!isLeaf) children[numKeys].traverse();\n    }\n\n    public BTreeNode search(int key) {\n        int i = 0;\n        while (i < numKeys && key > keys[i]) i++;\n        if (i < numKeys && keys[i] == key) return this;\n        if (isLeaf) return null;\n        return children[i].search(key);\n    }\n\n    public void insertNonFull(int key) {\n        int i = numKeys - 1;\n        if (isLeaf) {\n            while (i >= 0 && keys[i] > key) {\n                keys[i + 1] = keys[i];\n                i--;\n            }\n            keys[i + 1] = key;\n            numKeys++;\n        } else {\n            while (i >= 0 && keys[i] > key) i--;\n            if (children[i + 1].numKeys == 2 * t - 1) {\n                splitChild(i + 1, children[i + 1]);\n                if (keys[i + 1] < key) i++;\n            }\n            children[i + 1].insertNonFull(key);\n        }\n    }\n\n    public void splitChild(int i, BTreeNode y) {\n        BTreeNode z = new BTreeNode(y.t, y.isLeaf);\n        z.numKeys = t - 1;\n\n        for (int j = 0; j < t - 1; j++)\n            z.keys[j] = y.keys[j + t];\n\n        if (!y.isLeaf)\n            for (int j = 0; j < t; j++)\n                z.children[j] = y.children[j + t];\n\n        y.numKeys = t - 1;\n\n        for (int j = numKeys; j >= i + 1; j--)\n            children[j + 1] = children[j];\n\n        children[i + 1] = z;\n\n        for (int j = numKeys - 1; j >= i; j--)\n            keys[j + 1] = keys[j];\n\n        keys[i] = y.keys[t - 1];\n        numKeys++;\n    }\n\n    // Eliminaci\xf3n\n    public void remove(int key) {\n        int idx = findKey(key);\n\n        if (idx < numKeys && keys[idx] == key) {\n            if (isLeaf)\n                removeFromLeaf(idx);\n            else\n                removeFromNonLeaf(idx);\n        } else {\n            if (isLeaf) return; // No existe\n\n            boolean flag = (idx == numKeys);\n\n            if (children[idx].numKeys < t)\n                fill(idx);\n\n            if (flag && idx > numKeys)\n                children[idx - 1].remove(key);\n            else\n                children[idx].remove(key);\n        }\n    }\n\n    private int findKey(int key) {\n        int idx = 0;\n        while (idx < numKeys && keys[idx] < key) ++idx;\n        return idx;\n    }\n\n    private void removeFromLeaf(int idx) {\n        for (int i = idx + 1; i < numKeys; ++i)\n            keys[i - 1] = keys[i];\n        numKeys--;\n    }\n\n    private void removeFromNonLeaf(int idx) {\n        int k = keys[idx];\n        if (children[idx].numKeys >= t) {\n            int pred = getPredecessor(idx);\n            keys[idx] = pred;\n            children[idx].remove(pred);\n        } else if (children[idx + 1].numKeys >= t) {\n            int succ = getSuccessor(idx);\n            keys[idx] = succ;\n            children[idx + 1].remove(succ);\n        } else {\n            merge(idx);\n            children[idx].remove(k);\n        }\n    }\n\n    private int getPredecessor(int idx) {\n        BTreeNode cur = children[idx];\n        while (!cur.isLeaf)\n            cur = cur.children[cur.numKeys];\n        return cur.keys[cur.numKeys - 1];\n    }\n\n    private int getSuccessor(int idx) {\n        BTreeNode cur = children[idx + 1];\n        while (!cur.isLeaf)\n            cur = cur.children[0];\n        return cur.keys[0];\n    }\n\n    private void fill(int idx) {\n        if (idx != 0 && children[idx - 1].numKeys >= t)\n            borrowFromPrev(idx);\n        else if (idx != numKeys && children[idx + 1].numKeys >= t)\n            borrowFromNext(idx);\n        else {\n            if (idx != numKeys)\n                merge(idx);\n            else\n                merge(idx - 1);\n        }\n    }\n\n    private void borrowFromPrev(int idx) {\n        BTreeNode child = children[idx];\n        BTreeNode sibling = children[idx - 1];\n\n        for (int i = child.numKeys - 1; i >= 0; --i)\n            child.keys[i + 1] = child.keys[i];\n\n        if (!child.isLeaf)\n            for (int i = child.numKeys; i >= 0; --i)\n                child.children[i + 1] = child.children[i];\n\n        child.keys[0] = keys[idx - 1];\n\n        if (!child.isLeaf)\n            child.children[0] = sibling.children[sibling.numKeys];\n\n        keys[idx - 1] = sibling.keys[sibling.numKeys - 1];\n\n        child.numKeys += 1;\n        sibling.numKeys -= 1;\n    }\n\n    private void borrowFromNext(int idx) {\n        BTreeNode child = children[idx];\n        BTreeNode sibling = children[idx + 1];\n\n        child.keys[child.numKeys] = keys[idx];\n\n        if (!child.isLeaf)\n            child.children[child.numKeys + 1] = sibling.children[0];\n\n        keys[idx] = sibling.keys[0];\n\n        for (int i = 1; i < sibling.numKeys; ++i)\n            sibling.keys[i - 1] = sibling.keys[i];\n\n        if (!sibling.isLeaf)\n            for (int i = 1; i <= sibling.numKeys; ++i)\n                sibling.children[i - 1] = sibling.children[i];\n\n        child.numKeys += 1;\n        sibling.numKeys -= 1;\n    }\n\n    private void merge(int idx) {\n        BTreeNode child = children[idx];\n        BTreeNode sibling = children[idx + 1];\n\n        child.keys[t - 1] = keys[idx];\n\n        for (int i = 0; i < sibling.numKeys; ++i)\n            child.keys[i + t] = sibling.keys[i];\n\n        if (!child.isLeaf)\n            for (int i = 0; i <= sibling.numKeys; ++i)\n                child.children[i + t] = sibling.children[i];\n\n        for (int i = idx + 1; i < numKeys; ++i)\n            keys[i - 1] = keys[i];\n\n        for (int i = idx + 2; i <= numKeys; ++i)\n            children[i - 1] = children[i];\n\n        child.numKeys += sibling.numKeys + 1;\n        numKeys--;\n    }\n}\n'})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'showLineNumbers title="BTree.java"',children:"public class BTree {\n    private final int t;\n    private BTreeNode root;\n\n    public BTree(int t) {\n        this.t = t;\n        this.root = null;\n    }\n\n    public void traverse() {\n        if (root != null)\n            root.traverse();\n    }\n\n    public BTreeNode search(int key) {\n        return (root == null) ? null : root.search(key);\n    }\n\n    public void insert(int key) {\n        if (root == null) {\n            root = new BTreeNode(t, true);\n            root.keys[0] = key;\n            root.numKeys = 1;\n        } else {\n            if (root.numKeys == 2 * t - 1) {\n                BTreeNode s = new BTreeNode(t, false);\n                s.children[0] = root;\n                s.splitChild(0, root);\n\n                int i = 0;\n                if (s.keys[0] < key)\n                    i++;\n                s.children[i].insertNonFull(key);\n\n                root = s;\n            } else {\n                root.insertNonFull(key);\n            }\n        }\n    }\n\n    public void delete(int key) {\n        if (root == null)\n            return;\n\n        root.remove(key);\n\n        if (root.numKeys == 0) {\n            root = (root.isLeaf) ? null : root.children[0];\n        }\n    }\n}\n"})})]}),(0,t.jsx)(d.A,{value:"test",label:"Test Unitario",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:"showLineNumbers",children:"import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BTreeTest {\n\n    @Test\n    void testInsertAndSearch() {\n        BTree tree = new BTree(3);\n        tree.insert(10);\n        tree.insert(20);\n        tree.insert(5);\n        tree.insert(6);\n        tree.insert(12);\n        tree.insert(30);\n        tree.insert(7);\n        tree.insert(17);\n\n        assertNotNull(tree.search(6));\n        assertNotNull(tree.search(17));\n        assertNull(tree.search(99));\n    }\n\n    @Test\n    void testDelete() {\n        BTree tree = new BTree(3);\n        int[] keys = {10, 20, 5, 6, 12, 30, 7, 17};\n\n        for (int key : keys) tree.insert(key);\n        tree.delete(6);\n        assertNull(tree.search(6));\n\n        tree.delete(13); // no error\n        assertNull(tree.search(13));\n    }\n\n    @Test\n    void testTraverse() {\n        BTree tree = new BTree(3);\n        tree.insert(1);\n        tree.insert(3);\n        tree.insert(2);\n        tree.insert(5);\n        tree.insert(4);\n        tree.traverse(); // should print in order\n    }\n}\n"})})})]})}),(0,t.jsx)(d.A,{value:"python",label:"Paradigma: Procedural",children:(0,t.jsxs)(o.A,{children:[(0,t.jsx)(d.A,{value:"code",label:"C\xf3digo Python Ejemplo",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",metastring:"showLineNumbers",children:'from typing import Optional, List\n\ndef create_node(t: int, is_leaf: bool) -> dict:\n    return {\n        "keys": [],\n        "children": [],\n        "is_leaf": is_leaf,\n        "t": t\n    }\n\ndef search(node: Optional[dict], key: int) -> Optional[dict]:\n    if node is None:\n        return None\n    i = 0\n    while i < len(node["keys"]) and key > node["keys"][i]:\n        i += 1\n    if i < len(node["keys"]) and node["keys"][i] == key:\n        return node\n    if node["is_leaf"]:\n        return None\n    return search(node["children"][i], key)\n\ndef traverse(node: Optional[dict]) -> None:\n    if node is None:\n        return\n    for i in range(len(node["keys"])):\n        if not node["is_leaf"]:\n            traverse(node["children"][i])\n        print(node["keys"][i], end=\' \')\n    if not node["is_leaf"]:\n        traverse(node["children"][len(node["keys"])])\n\ndef split_child(parent: dict, i: int, t: int) -> None:\n    y = parent["children"][i]\n    z = create_node(t, y["is_leaf"])\n    z["keys"] = y["keys"][t:]\n    if not y["is_leaf"]:\n        z["children"] = y["children"][t:]\n    y["keys"] = y["keys"][:t - 1]\n    y["children"] = y["children"][:t] if not y["is_leaf"] else y["children"]\n    parent["children"].insert(i + 1, z)\n    parent["keys"].insert(i, y["keys"].pop())\n\ndef insert_non_full(node: dict, key: int) -> None:\n    i = len(node["keys"]) - 1\n    if node["is_leaf"]:\n        node["keys"].append(0)\n        while i >= 0 and key < node["keys"][i]:\n            node["keys"][i + 1] = node["keys"][i]\n            i -= 1\n        node["keys"][i + 1] = key\n    else:\n        while i >= 0 and key < node["keys"][i]:\n            i -= 1\n        i += 1\n        if len(node["children"][i]["keys"]) == 2 * node["t"] - 1:\n            split_child(node, i, node["t"])\n            if key > node["keys"][i]:\n                i += 1\n        insert_non_full(node["children"][i], key)\n\ndef insert(tree: dict, key: int) -> None:\n    root = tree["root"]\n    if len(root["keys"]) == 2 * root["t"] - 1:\n        new_root = create_node(root["t"], False)\n        new_root["children"].append(root)\n        split_child(new_root, 0, root["t"])\n        insert_non_full(new_root, key)\n        tree["root"] = new_root\n    else:\n        insert_non_full(root, key)\n\ndef get_predecessor(node: dict) -> int:\n    current = node\n    while not current["is_leaf"]:\n        current = current["children"][-1]\n    return current["keys"][-1]\n\ndef get_successor(node: dict) -> int:\n    current = node\n    while not current["is_leaf"]:\n        current = current["children"][0]\n    return current["keys"][0]\n\ndef merge(node: dict, idx: int) -> None:\n    t = node["t"]\n    child = node["children"][idx]\n    sibling = node["children"][idx + 1]\n    child["keys"].append(node["keys"].pop(idx))\n    child["keys"].extend(sibling["keys"])\n    if not child["is_leaf"]:\n        child["children"].extend(sibling["children"])\n    node["children"].pop(idx + 1)\n\ndef fill(node: dict, idx: int) -> None:\n    t = node["t"]\n    if idx > 0 and len(node["children"][idx - 1]["keys"]) >= t:\n        borrow_from_prev(node, idx)\n    elif idx < len(node["children"]) - 1 and len(node["children"][idx + 1]["keys"]) >= t:\n        borrow_from_next(node, idx)\n    else:\n        if idx < len(node["children"]) - 1:\n            merge(node, idx)\n        else:\n            merge(node, idx - 1)\n\ndef borrow_from_prev(node: dict, idx: int) -> None:\n    child = node["children"][idx]\n    sibling = node["children"][idx - 1]\n    child["keys"].insert(0, node["keys"][idx - 1])\n    if not sibling["is_leaf"]:\n        child["children"].insert(0, sibling["children"].pop())\n    node["keys"][idx - 1] = sibling["keys"].pop()\n\ndef borrow_from_next(node: dict, idx: int) -> None:\n    child = node["children"][idx]\n    sibling = node["children"][idx + 1]\n    child["keys"].append(node["keys"][idx])\n    if not sibling["is_leaf"]:\n        child["children"].append(sibling["children"].pop(0))\n    node["keys"][idx] = sibling["keys"].pop(0)\n\ndef delete_from_leaf(node: dict, idx: int) -> None:\n    node["keys"].pop(idx)\n\ndef delete_from_non_leaf(node: dict, idx: int) -> None:\n    key = node["keys"][idx]\n    if len(node["children"][idx]["keys"]) >= node["t"]:\n        pred = get_predecessor(node["children"][idx])\n        node["keys"][idx] = pred\n        delete(node["children"][idx], pred)\n    elif len(node["children"][idx + 1]["keys"]) >= node["t"]:\n        succ = get_successor(node["children"][idx + 1])\n        node["keys"][idx] = succ\n        delete(node["children"][idx + 1], succ)\n    else:\n        merge(node, idx)\n        delete(node["children"][idx], key)\n\ndef delete(node: dict, key: int) -> None:\n    idx = 0\n    while idx < len(node["keys"]) and key > node["keys"][idx]:\n        idx += 1\n\n    if idx < len(node["keys"]) and node["keys"][idx] == key:\n        if node["is_leaf"]:\n            delete_from_leaf(node, idx)\n        else:\n            delete_from_non_leaf(node, idx)\n    else:\n        if node["is_leaf"]:\n            return  # Key not found\n        if len(node["children"][idx]["keys"]) < node["t"]:\n            fill(node, idx)\n        if idx < len(node["keys"]) and key > node["keys"][idx]:\n            idx += 1\n        delete(node["children"][idx], key)\n\ndef create_btree(t: int) -> dict:\n    return {\n        "root": create_node(t, True)\n    }\n'})})}),(0,t.jsx)(d.A,{value:"test",label:"Test Unitario",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",metastring:"showLineNumbers",children:'import unittest\nfrom btree import *\n\nclass TestBTreeProcedural(unittest.TestCase):\n    def setUp(self):\n        self.tree = create_btree(3)\n        for key in [10, 20, 5, 6, 12, 30, 7, 17]:\n            insert(self.tree, key)\n\n    def test_search(self):\n        self.assertIsNotNone(search(self.tree["root"], 12))\n        self.assertIsNone(search(self.tree["root"], 100))\n\n    def test_traverse(self):\n        traverse(self.tree["root"])  # Output: should be in sorted order\n\n    def test_delete_existing_key(self):\n        delete(self.tree["root"], 6)\n        self.assertIsNone(search(self.tree["root"], 6))\n\n    def test_delete_non_existing_key(self):\n        delete(self.tree["root"], 100)  # No crash\n        self.assertIsNone(search(self.tree["root"], 100))\n\nif __name__ == \'__main__\':\n    unittest.main()\n'})})})]})}),(0,t.jsx)(d.A,{value:"ts",label:"Paradigma: Funcional",children:(0,t.jsxs)(o.A,{children:[(0,t.jsx)(d.A,{value:"code",label:"C\xf3digo TS Ejemplo",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"export type BNode = {\n  keys: number[];\n  children: BNode[];\n  isLeaf: boolean;\n};\n\nexport type BTree = {\n  t: number;\n  root: BNode;\n};\n\n// Crear nodo\nexport const createNode = (isLeaf: boolean): BNode => ({\n  keys: [],\n  children: [],\n  isLeaf\n});\n\n// Crear \xe1rbol\nexport const createBTree = (t: number): BTree => ({\n  t,\n  root: createNode(true)\n});\n\n// Buscar clave\nexport const search = (node: BNode, key: number): BNode | null => {\n  let i = 0;\n  while (i < node.keys.length && key > node.keys[i]) i++;\n  if (i < node.keys.length && node.keys[i] === key) return node;\n  if (node.isLeaf) return null;\n  return search(node.children[i], key);\n};\n\n// Recorrer \xe1rbol\nexport const traverse = (node: BNode): number[] => {\n  let result: number[] = [];\n  for (let i = 0; i < node.keys.length; i++) {\n    if (!node.isLeaf) result = result.concat(traverse(node.children[i]));\n    result.push(node.keys[i]);\n  }\n  if (!node.isLeaf) result = result.concat(traverse(node.children[node.keys.length]));\n  return result;\n};\n\n// Dividir hijo\nconst splitChild = (parent: BNode, i: number, t: number) => {\n  const y = parent.children[i];\n  const z = createNode(y.isLeaf);\n  z.keys = y.keys.splice(t); // mitad superior\n  if (!y.isLeaf) z.children = y.children.splice(t);\n  const middle = y.keys.splice(t - 1, 1)[0];\n  parent.children.splice(i + 1, 0, z);\n  parent.keys.splice(i, 0, middle);\n};\n\n// Insertar en nodo no lleno\nconst insertNonFull = (node: BNode, key: number, t: number): void => {\n  let i = node.keys.length - 1;\n  if (node.isLeaf) {\n    node.keys.push(key);\n    node.keys.sort((a, b) => a - b);\n  } else {\n    while (i >= 0 && key < node.keys[i]) i--;\n    i++;\n    if (node.children[i].keys.length === 2 * t - 1) {\n      splitChild(node, i, t);\n      if (key > node.keys[i]) i++;\n    }\n    insertNonFull(node.children[i], key, t);\n  }\n};\n\n// Insertar\nexport const insert = (tree: BTree, key: number): void => {\n  const { root, t } = tree;\n  if (root.keys.length === 2 * t - 1) {\n    const newRoot = createNode(false);\n    newRoot.children.push(root);\n    splitChild(newRoot, 0, t);\n    insertNonFull(newRoot, key, t);\n    tree.root = newRoot;\n  } else {\n    insertNonFull(root, key, t);\n  }\n};\n\n// Obtener predecesor\nconst getPredecessor = (node: BNode): number => {\n  let current = node;\n  while (!current.isLeaf) current = current.children[current.children.length - 1];\n  return current.keys[current.keys.length - 1];\n};\n\n// Obtener sucesor\nconst getSuccessor = (node: BNode): number => {\n  let current = node;\n  while (!current.isLeaf) current = current.children[0];\n  return current.keys[0];\n};\n\n// Fusionar nodos\nconst merge = (node: BNode, idx: number, t: number) => {\n  const child = node.children[idx];\n  const sibling = node.children[idx + 1];\n  child.keys.push(node.keys[idx]);\n  child.keys = child.keys.concat(sibling.keys);\n  if (!child.isLeaf) {\n    child.children = child.children.concat(sibling.children);\n  }\n  node.keys.splice(idx, 1);\n  node.children.splice(idx + 1, 1);\n};\n\n// Llenar hijo antes de borrar\nconst fill = (node: BNode, idx: number, t: number) => {\n  if (idx > 0 && node.children[idx - 1].keys.length >= t) {\n    borrowFromPrev(node, idx);\n  } else if (idx < node.children.length - 1 && node.children[idx + 1].keys.length >= t) {\n    borrowFromNext(node, idx);\n  } else {\n    if (idx < node.children.length - 1) merge(node, idx, t);\n    else merge(node, idx - 1, t);\n  }\n};\n\n// Pedir clave prestada al hermano izquierdo\nconst borrowFromPrev = (node: BNode, idx: number) => {\n  const child = node.children[idx];\n  const sibling = node.children[idx - 1];\n  child.keys.unshift(node.keys[idx - 1]);\n  if (!child.isLeaf) {\n    child.children.unshift(sibling.children.pop()!);\n  }\n  node.keys[idx - 1] = sibling.keys.pop()!;\n};\n\n// Pedir clave prestada al hermano derecho\nconst borrowFromNext = (node: BNode, idx: number) => {\n  const child = node.children[idx];\n  const sibling = node.children[idx + 1];\n  child.keys.push(node.keys[idx]);\n  if (!child.isLeaf) {\n    child.children.push(sibling.children.shift()!);\n  }\n  node.keys[idx] = sibling.keys.shift()!;\n};\n\n// Borrar de hoja\nconst deleteFromLeaf = (node: BNode, idx: number) => {\n  node.keys.splice(idx, 1);\n};\n\n// Borrar de nodo interno\nconst deleteFromNonLeaf = (node: BNode, idx: number, t: number) => {\n  const key = node.keys[idx];\n  const left = node.children[idx];\n  const right = node.children[idx + 1];\n  if (left.keys.length >= t) {\n    const pred = getPredecessor(left);\n    node.keys[idx] = pred;\n    deleteKey(left, pred, t);\n  } else if (right.keys.length >= t) {\n    const succ = getSuccessor(right);\n    node.keys[idx] = succ;\n    deleteKey(right, succ, t);\n  } else {\n    merge(node, idx, t);\n    deleteKey(left, key, t);\n  }\n};\n\n// Eliminar clave\nexport const deleteKey = (node: BNode, key: number, t: number): void => {\n  let idx = node.keys.findIndex(k => k >= key);\n  if (idx !== -1 && node.keys[idx] === key) {\n    node.isLeaf ? deleteFromLeaf(node, idx) : deleteFromNonLeaf(node, idx, t);\n  } else {\n    if (node.isLeaf) return;\n    if (idx === -1) idx = node.keys.length;\n    if (node.children[idx].keys.length < t) fill(node, idx, t);\n    deleteKey(node.children[idx], key, t);\n  }\n};\n"})})}),(0,t.jsx)(d.A,{value:"test",label:"Test Unitario",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"import { describe, it, expect, beforeEach } from 'vitest';\nimport { createBTree, insert, search, traverse, deleteKey } from './btree';\n\ndescribe('Functional B-Tree', () => {\n  let tree: ReturnType<typeof createBTree>;\n\n  beforeEach(() => {\n    tree = createBTree(3);\n    [10, 20, 5, 6, 12, 30, 7, 17].forEach(v => insert(tree, v));\n  });\n\n  it('should insert and traverse keys', () => {\n    const values = traverse(tree.root);\n    expect(values).toEqual([5, 6, 7, 10, 12, 17, 20, 30]);\n  });\n\n  it('should find existing key', () => {\n    const found = search(tree.root, 12);\n    expect(found).not.toBeNull();\n  });\n\n  it('should not find missing key', () => {\n    const found = search(tree.root, 99);\n    expect(found).toBeNull();\n  });\n\n  it('should delete a key and not find it again', () => {\n    deleteKey(tree.root, 6, tree.t);\n    expect(search(tree.root, 6)).toBeNull();\n  });\n\n  it('should handle deletion of non-existent key gracefully', () => {\n    deleteKey(tree.root, 1000, tree.t);\n    expect(search(tree.root, 1000)).toBeNull();\n  });\n});\n"})})})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"ejemplo-t\xe9cnico-b-tree-1",children:"Ejemplo t\xe9cnico B+ Tree"}),"\n",(0,t.jsxs)(o.A,{children:[(0,t.jsx)(d.A,{value:"java",label:"Paradigma: Orientado a Objetos",children:(0,t.jsxs)(o.A,{children:[(0,t.jsxs)(d.A,{value:"code",label:"C\xf3digo Java Ejemplo",children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:'showLineNumbers title="BPlusNode.java"',children:"import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Represents a node in a B+ Tree.\n * Each node can store multiple keys and child pointers.\n */\npublic class BPlusNode {\n    List<Integer> keys;\n    List<BPlusNode> children;\n    BPlusNode parent;\n    boolean isLeaf;\n    BPlusNode next; // For linked leaf nodes\n\n    public BPlusNode(boolean isLeaf) {\n        this.isLeaf = isLeaf;\n        this.keys = new ArrayList<>();\n        this.children = new ArrayList<>();\n        this.parent = null;\n        this.next = null;\n    }\n\n    public boolean isOverflow(int order) {\n        return keys.size() > order - 1;\n    }\n\n    public boolean isUnderflow(int order) {\n        return keys.size() < Math.ceil(order / 2.0) - 1;\n    }\n\n    @Override\n    public String toString() {\n        return keys.toString();\n    }\n}\n"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:"showLineNumbers",children:'package edu.usta.tree.bplus;\n\nimport java.util.*;\n\n/**\n * Implementation of a B+ Tree with insert, search, delete and traversal.\n * Order defines the maximum number of children per node.\n */\npublic class BPlusTree {\n    private final int order;\n    private BPlusNode root;\n\n    public BPlusTree(int order) {\n        this.order = order;\n        this.root = new BPlusNode(true);\n    }\n\n    /** Search key in the tree */\n    public boolean search(int key) {\n        BPlusNode node = findLeafNode(root, key);\n        return node.keys.contains(key);\n    }\n\n    /** Insert a key */\n    public void insert(int key) {\n        BPlusNode leaf = findLeafNode(root, key);\n        insertInLeaf(leaf, key);\n\n        if (leaf.isOverflow(order)) {\n            splitNode(leaf);\n        }\n    }\n\n    /** Delete a key */\n    public void delete(int key) {\n        BPlusNode leaf = findLeafNode(root, key);\n        if (!leaf.keys.contains(key)) return;\n\n        leaf.keys.remove(Integer.valueOf(key));\n\n        if (leaf == root) {\n            if (leaf.keys.isEmpty()) root = new BPlusNode(true);\n            return;\n        }\n\n        if (leaf.isUnderflow(order)) {\n            rebalanceAfterDeletion(leaf);\n        }\n    }\n\n    /** Print the tree level by level */\n    public void printTree() {\n        Queue<BPlusNode> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            for (int i = 0; i < levelSize; i++) {\n                BPlusNode node = queue.poll();\n                System.out.print(node.keys + " ");\n                if (!node.isLeaf) queue.addAll(node.children);\n            }\n            System.out.println();\n        }\n    }\n\n    /** Find leaf node for a given key */\n    private BPlusNode findLeafNode(BPlusNode node, int key) {\n        while (!node.isLeaf) {\n            int i = 0;\n            while (i < node.keys.size() && key >= node.keys.get(i)) i++;\n            node = node.children.get(i);\n        }\n        return node;\n    }\n\n    /** Insert key in leaf */\n    private void insertInLeaf(BPlusNode leaf, int key) {\n        int pos = 0;\n        while (pos < leaf.keys.size() && leaf.keys.get(pos) < key) pos++;\n        leaf.keys.add(pos, key);\n    }\n\n    /** Split an overflowing node */\n    private void splitNode(BPlusNode node) {\n        int midIndex = node.keys.size() / 2;\n        BPlusNode sibling = new BPlusNode(node.isLeaf);\n        sibling.parent = node.parent;\n\n        // Move half of the keys\n        sibling.keys.addAll(node.keys.subList(midIndex, node.keys.size()));\n        node.keys = new ArrayList<>(node.keys.subList(0, midIndex));\n\n        // Leaf split\n        if (node.isLeaf) {\n            sibling.next = node.next;\n            node.next = sibling;\n        } else { // Internal split\n            sibling.children.addAll(node.children.subList(midIndex + 1, node.children.size()));\n            for (BPlusNode child : sibling.children) child.parent = sibling;\n            node.children = new ArrayList<>(node.children.subList(0, midIndex + 1));\n        }\n\n        int upKey = sibling.keys.get(0);\n        if (node.isLeaf) upKey = sibling.keys.get(0); // propagate smallest key up\n\n        if (node.parent == null) {\n            BPlusNode newRoot = new BPlusNode(false);\n            newRoot.keys.add(upKey);\n            newRoot.children.add(node);\n            newRoot.children.add(sibling);\n            node.parent = newRoot;\n            sibling.parent = newRoot;\n            root = newRoot;\n        } else {\n            BPlusNode parent = node.parent;\n            int insertPos = 0;\n            while (insertPos < parent.keys.size() && parent.keys.get(insertPos) < upKey) insertPos++;\n            parent.keys.add(insertPos, upKey);\n            parent.children.add(insertPos + 1, sibling);\n            if (parent.isOverflow(order)) splitNode(parent);\n        }\n    }\n\n    /** Rebalance after deletion */\n    private void rebalanceAfterDeletion(BPlusNode node) {\n        BPlusNode parent = node.parent;\n        if (parent == null) return;\n\n        int index = parent.children.indexOf(node);\n        BPlusNode leftSibling = (index > 0) ? parent.children.get(index - 1) : null;\n        BPlusNode rightSibling = (index < parent.children.size() - 1) ? parent.children.get(index + 1) : null;\n\n        if (leftSibling != null && leftSibling.keys.size() > Math.ceil(order / 2.0) - 1) {\n            int borrowedKey = leftSibling.keys.remove(leftSibling.keys.size() - 1);\n            node.keys.add(0, borrowedKey);\n            parent.keys.set(index - 1, node.keys.get(0));\n        } else if (rightSibling != null && rightSibling.keys.size() > Math.ceil(order / 2.0) - 1) {\n            int borrowedKey = rightSibling.keys.remove(0);\n            node.keys.add(borrowedKey);\n            parent.keys.set(index, rightSibling.keys.get(0));\n        } else {\n            if (leftSibling != null) {\n                leftSibling.keys.addAll(node.keys);\n                leftSibling.next = node.next;\n                parent.keys.remove(index - 1);\n                parent.children.remove(node);\n            } else if (rightSibling != null) {\n                node.keys.addAll(rightSibling.keys);\n                node.next = rightSibling.next;\n                parent.keys.remove(index);\n                parent.children.remove(rightSibling);\n            }\n\n            if (parent == root && parent.keys.isEmpty()) {\n                root = node;\n                node.parent = null;\n            } else if (parent.isUnderflow(order)) {\n                rebalanceAfterDeletion(parent);\n            }\n        }\n    }\n\n    /** For testing */\n    public List<Integer> traverseLeafKeys() {\n        List<Integer> result = new ArrayList<>();\n        BPlusNode current = root;\n        while (!current.isLeaf) current = current.children.get(0);\n        while (current != null) {\n            result.addAll(current.keys);\n            current = current.next;\n        }\n        return result;\n    }\n}\n'})})]}),(0,t.jsx)(d.A,{value:"test",label:"Test Unitario",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",metastring:"showLineNumbers",children:"import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.List;\n\npublic class BPlusTreeTest {\n    @Test\n    void testInsertAndSearch() {\n        BPlusTree tree = new BPlusTree(3);\n        int[] keys = {10, 20, 5, 6, 12, 30, 7, 17};\n\n        for (int k : keys) tree.insert(k);\n\n        assertTrue(tree.search(6));\n        assertTrue(tree.search(20));\n        assertFalse(tree.search(100));\n\n        List<Integer> result = tree.traverseLeafKeys();\n        assertEquals(List.of(5, 6, 7, 10, 12, 17, 20, 30), result);\n    }\n\n    @Test\n    void testDelete() {\n        BPlusTree tree = new BPlusTree(3);\n        for (int k : new int[]{10, 20, 5, 6, 12, 30, 7, 17}) tree.insert(k);\n\n        tree.delete(6);\n        assertFalse(tree.search(6));\n\n        tree.delete(17);\n        assertFalse(tree.search(17));\n\n        List<Integer> result = tree.traverseLeafKeys();\n        assertEquals(List.of(5, 7, 10, 12, 20, 30), result);\n    }\n\n    @Test\n    void testPrintTree() {\n        BPlusTree tree = new BPlusTree(3);\n        for (int k : new int[]{10, 20, 5, 6, 12, 30, 7, 17}) tree.insert(k);\n        tree.printTree(); // Manual verification of structure\n    }\n}\n"})})})]})}),(0,t.jsx)(d.A,{value:"python",label:"Paradigma: Procedural",children:(0,t.jsxs)(o.A,{children:[(0,t.jsx)(d.A,{value:"code",label:"C\xf3digo Python Ejemplo",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",metastring:"showLineNumbers",children:'from typing import Optional, List\n\n# ===============================================================\n#   CREACI\xd3N DE NODOS Y \xc1RBOLES\n# ===============================================================\n\ndef create_node(is_leaf: bool) -> dict:\n    return {\n        "keys": [],\n        "children": [],\n        "is_leaf": is_leaf,\n        "next": None,\n        "parent": None\n    }\n\ndef create_bplustree(order: int) -> dict:\n    return {\n        "order": order,\n        "root": create_node(True)\n    }\n\n# ===============================================================\n#   B\xdaSQUEDA\n# ===============================================================\n\ndef find_leaf(node: dict, key: int) -> dict:\n    while not node["is_leaf"]:\n        i = 0\n        while i < len(node["keys"]) and key >= node["keys"][i]:\n            i += 1\n        node = node["children"][i]\n    return node\n\ndef search(tree: dict, key: int) -> bool:\n    leaf = find_leaf(tree["root"], key)\n    return key in leaf["keys"]\n\n# ===============================================================\n#   INSERCI\xd3N\n# ===============================================================\n\ndef insert_key(tree: dict, key: int):\n    root = tree["root"]\n    leaf = find_leaf(root, key)\n    insert_in_leaf(leaf, key)\n\n    order = tree["order"]\n    if len(leaf["keys"]) > order - 1:\n        split_node(tree, leaf)\n\ndef insert_in_leaf(leaf: dict, key: int):\n    leaf["keys"].append(key)\n    leaf["keys"].sort()\n\ndef split_node(tree: dict, node: dict):\n    order = tree["order"]\n    mid = len(node["keys"]) // 2\n\n    new_node = create_node(node["is_leaf"])\n    new_node["parent"] = node["parent"]\n    new_node["keys"] = node["keys"][mid:] if node["is_leaf"] else node["keys"][mid + 1:]\n    node["keys"] = node["keys"][:mid]\n\n    if node["is_leaf"]:\n        new_node["next"] = node["next"]\n        node["next"] = new_node\n    else:\n        new_node["children"] = node["children"][mid + 1:]\n        node["children"] = node["children"][:mid + 1]\n        for c in new_node["children"]:\n            c["parent"] = new_node\n\n    up_key = new_node["keys"][0]\n\n    if node["parent"] is None:\n        new_root = create_node(False)\n        new_root["keys"] = [up_key]\n        new_root["children"] = [node, new_node]\n        node["parent"] = new_root\n        new_node["parent"] = new_root\n        tree["root"] = new_root\n    else:\n        parent = node["parent"]\n        idx = 0\n        while idx < len(parent["keys"]) and up_key > parent["keys"][idx]:\n            idx += 1\n        parent["keys"].insert(idx, up_key)\n        parent["children"].insert(idx + 1, new_node)\n        new_node["parent"] = parent\n\n        if len(parent["keys"]) > order - 1:\n            split_node(tree, parent)\n\n# ===============================================================\n#   ELIMINACI\xd3N\n# ===============================================================\n\ndef delete_key(tree: dict, key: int):\n    leaf = find_leaf(tree["root"], key)\n    if key not in leaf["keys"]:\n        return\n\n    leaf["keys"].remove(key)\n\n    if leaf == tree["root"]:\n        if not leaf["keys"]:\n            tree["root"] = create_node(True)\n        return\n\n    order = tree["order"]\n    if len(leaf["keys"]) < (order // 2):\n        rebalance(tree, leaf)\n\ndef rebalance(tree: dict, node: dict):\n    parent = node["parent"]\n    if parent is None:\n        return\n\n    idx = parent["children"].index(node)\n    left = parent["children"][idx - 1] if idx > 0 else None\n    right = parent["children"][idx + 1] if idx < len(parent["children"]) - 1 else None\n    order = tree["order"]\n\n    if left and len(left["keys"]) > (order // 2):\n        borrowed_key = left["keys"].pop(-1)\n        node["keys"].insert(0, borrowed_key)\n        parent["keys"][idx - 1] = node["keys"][0]\n    elif right and len(right["keys"]) > (order // 2):\n        borrowed_key = right["keys"].pop(0)\n        node["keys"].append(borrowed_key)\n        parent["keys"][idx] = right["keys"][0]\n    else:\n        if left:\n            left["keys"].extend(node["keys"])\n            left["next"] = node["next"]\n            parent["keys"].pop(idx - 1)\n            parent["children"].remove(node)\n        elif right:\n            node["keys"].extend(right["keys"])\n            node["next"] = right["next"]\n            parent["keys"].pop(idx)\n            parent["children"].remove(right)\n\n        if parent == tree["root"] and not parent["keys"]:\n            tree["root"] = left or node\n            tree["root"]["parent"] = None\n        elif len(parent["keys"]) < (order // 2):\n            rebalance(tree, parent)\n\n# ===============================================================\n#   RECORRIDO\n# ===============================================================\n\ndef traverse_leaves(tree: dict) -> List[int]:\n    node = tree["root"]\n    while not node["is_leaf"]:\n        node = node["children"][0]\n\n    result = []\n    while node:\n        result.extend(node["keys"])\n        node = node["next"]\n    return result\n'})})}),(0,t.jsx)(d.A,{value:"test",label:"Test Unitario",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",metastring:"showLineNumbers",children:'import unittest\nfrom bplus_tree import *\n\nclass TestBPlusTreeProcedural(unittest.TestCase):\n\n    def setUp(self):\n        self.tree = create_bplustree(3)\n        for key in [10, 20, 5, 6, 12, 30, 7, 17]:\n            insert_key(self.tree, key)\n\n    def test_search_existing_and_missing(self):\n        self.assertTrue(search(self.tree, 6))\n        self.assertFalse(search(self.tree, 99))\n\n    def test_traverse_leaves(self):\n        expected = [5, 6, 7, 10, 12, 17, 20, 30]\n        self.assertEqual(traverse_leaves(self.tree), expected)\n\n    def test_delete_key(self):\n        delete_key(self.tree, 6)\n        delete_key(self.tree, 17)\n        self.assertFalse(search(self.tree, 6))\n        self.assertFalse(search(self.tree, 17))\n        expected = [5, 7, 10, 12, 20, 30]\n        self.assertEqual(traverse_leaves(self.tree), expected)\n\n    def test_delete_non_existing_key(self):\n        delete_key(self.tree, 999)  # No error expected\n        self.assertFalse(search(self.tree, 999))\n\nif __name__ == "__main__":\n    unittest.main()\n'})})})]})}),(0,t.jsx)(d.A,{value:"ts",label:"Paradigma: Funcional",children:(0,t.jsxs)(o.A,{children:[(0,t.jsx)(d.A,{value:"code",label:"C\xf3digo TS Ejemplo",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"export type BPlusNode = Readonly<{\n  isLeaf: boolean\n  keys: number[]\n  children?: BPlusNode[]\n  values?: number[][]\n  next?: BPlusNode\n}>\n\nexport type BPlusTree = Readonly<{\n  order: number\n  root: BPlusNode\n}>\n\nexport const createLeafNode = (): BPlusNode => ({\n  isLeaf: true,\n  keys: [],\n  values: [],\n})\n\nexport const createInternalNode = (keys: number[], children: BPlusNode[]): BPlusNode => ({\n  isLeaf: false,\n  keys,\n  children,\n})\n\nconst splitLeaf = (leaf: BPlusNode, order: number): [number, BPlusNode, BPlusNode] => {\n  const mid = Math.floor(order / 2)\n  const left: BPlusNode = {\n    ...leaf,\n    keys: leaf.keys.slice(0, mid),\n    values: leaf.values?.slice(0, mid),\n  }\n  const right: BPlusNode = {\n    ...leaf,\n    keys: leaf.keys.slice(mid),\n    values: leaf.values?.slice(mid),\n    next: leaf.next,\n  }\n  left.next = right\n  return [right.keys[0], left, right]\n}\n\nconst splitInternal = (node: BPlusNode, order: number): [number, BPlusNode, BPlusNode] => {\n  const mid = Math.floor(order / 2)\n  const [leftKeys, rightKeys] = [node.keys.slice(0, mid), node.keys.slice(mid + 1)]\n  const [leftChildren, rightChildren] = [node.children!.slice(0, mid + 1), node.children!.slice(mid + 1)]\n  return [\n    node.keys[mid],\n    createInternalNode(leftKeys, leftChildren),\n    createInternalNode(rightKeys, rightChildren),\n  ]\n}\n\nexport const insert = (tree: BPlusTree, key: number, value: number): BPlusTree => {\n  const insertRecursive = (\n    node: BPlusNode\n  ): [boolean, number?, BPlusNode?, BPlusNode?] => {\n    if (node.isLeaf) {\n      const idx = node.keys.findIndex(k => k >= key)\n      if (idx >= 0 && node.keys[idx] === key) return [false]\n\n      const newKeys = [...node.keys]\n      const newValues = [...(node.values ?? [])]\n      const insertPos = idx >= 0 ? idx : node.keys.length\n      newKeys.splice(insertPos, 0, key)\n      newValues.splice(insertPos, 0, [value])\n      const newLeaf: BPlusNode = { ...node, keys: newKeys, values: newValues }\n\n      if (newKeys.length < tree.order) return [true, undefined, newLeaf]\n\n      const [promoted, left, right] = splitLeaf(newLeaf, tree.order)\n      return [true, promoted, left, right]\n    }\n\n    const idx = node.keys.findIndex(k => key < k)\n    const childIdx = idx === -1 ? node.keys.length : idx\n    const [inserted, promoted, leftChild, rightChild] = insertRecursive(node.children![childIdx])\n\n    if (!inserted) return [false]\n\n    if (!promoted) {\n      const newChildren = [...node.children!]\n      newChildren[childIdx] = leftChild!\n      return [true, undefined, { ...node, children: newChildren }]\n    }\n\n    const newKeys = [...node.keys]\n    const newChildren = [...node.children!]\n    newKeys.splice(childIdx, 0, promoted)\n    newChildren.splice(childIdx, 1, leftChild!, rightChild!)\n\n    const newNode: BPlusNode = { ...node, keys: newKeys, children: newChildren }\n\n    if (newKeys.length < tree.order) return [true, undefined, newNode]\n\n    const [middleKey, left, right] = splitInternal(newNode, tree.order)\n    return [true, middleKey, left, right]\n  }\n\n  const [inserted, promoted, left, right] = insertRecursive(tree.root)\n\n  if (!inserted) return tree\n\n  if (!promoted) {\n    return { ...tree, root: left! }\n  }\n\n  const newRoot = createInternalNode([promoted!], [left!, right!])\n  return { ...tree, root: newRoot }\n}\n\nexport const search = (tree: BPlusTree, key: number): number[] | undefined => {\n  let node = tree.root\n  while (!node.isLeaf) {\n    const idx = node.keys.findIndex(k => key < k)\n    node = node.children![idx === -1 ? node.keys.length : idx]\n  }\n  const i = node.keys.indexOf(key)\n  return i !== -1 ? node.values![i] : undefined\n}\n\nexport const traverse = (tree: BPlusTree): number[] => {\n  let node = tree.root\n  while (!node.isLeaf) node = node.children![0]\n  const result: number[] = []\n  while (node) {\n    result.push(...node.keys)\n    node = node.next!\n  }\n  return result\n}\n\nexport const remove = (tree: BPlusTree, key: number): BPlusTree => {\n  const removeLeaf = (node: BPlusNode): BPlusNode => {\n    const idx = node.keys.indexOf(key)\n    if (idx === -1) return node\n    const newKeys = [...node.keys]\n    const newValues = [...(node.values ?? [])]\n    newKeys.splice(idx, 1)\n    newValues.splice(idx, 1)\n    return { ...node, keys: newKeys, values: newValues }\n  }\n\n  const removeRecursive = (node: BPlusNode): BPlusNode => {\n    if (node.isLeaf) return removeLeaf(node)\n\n    const idx = node.keys.findIndex(k => key < k)\n    const childIdx = idx === -1 ? node.keys.length : idx\n    const updatedChild = removeRecursive(node.children![childIdx])\n    const newChildren = [...node.children!]\n    newChildren[childIdx] = updatedChild\n    return { ...node, children: newChildren }\n  }\n\n  return { ...tree, root: removeRecursive(tree.root) }\n}\n\nexport const createTree = (order: number): BPlusTree => ({\n  order,\n  root: createLeafNode(),\n})\n"})})}),(0,t.jsx)(d.A,{value:"test",label:"Test Unitario",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"showLineNumbers",children:"import { describe, expect, it, beforeEach } from 'vitest'\nimport { createTree, insert, search, traverse, remove } from './bplus-tree'\n\ndescribe('B+ Tree Functional', () => {\n  let tree = createTree(3)\n\n  beforeEach(() => {\n    tree = createTree(3)\n    for (const key of [10, 20, 5, 6, 12, 30, 7, 17]) {\n      tree = insert(tree, key, key)\n    }\n  })\n\n  it('should insert and search keys', () => {\n    expect(search(tree, 12)).toEqual([12])\n    expect(search(tree, 99)).toBeUndefined()\n  })\n\n  it('should traverse leaves in order', () => {\n    expect(traverse(tree)).toEqual([5, 6, 7, 10, 12, 17, 20, 30])\n  })\n\n  it('should remove a key', () => {\n    tree = remove(tree, 10)\n    tree = remove(tree, 6)\n    expect(search(tree, 10)).toBeUndefined()\n    expect(search(tree, 6)).toBeUndefined()\n    expect(traverse(tree)).toEqual([5, 7, 12, 17, 20, 30])\n  })\n\n  it('should ignore removal of non-existing key', () => {\n    tree = remove(tree, 999)\n    expect(search(tree, 999)).toBeUndefined()\n  })\n})\n"})})})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"aplicaciones-pr\xe1cticas",children:"Aplicaciones pr\xe1cticas"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Bases de datos (MySQL, PostgreSQL, Oracle): \xedndices tipo B+ Tree."}),"\n",(0,t.jsx)(n.li,{children:"Sistemas de archivos: NTFS (Windows), HFS+ (macOS), Ext4 (Linux)."}),"\n",(0,t.jsx)(n.li,{children:"Almacenamiento en disco: lectura secuencial optimizada."}),"\n",(0,t.jsx)(n.li,{children:"Sistemas OLAP: permiten exploraci\xf3n r\xe1pida de rangos."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"referencias",children:"Referencias"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Bayer, R., & McCreight, E. M. (1972). ",(0,t.jsx)(n.a,{href:"https://doi.org/10.1007/BF00288683",children:"Organization and Maintenance of Large Ordered Indexes. Acta Informatica, 1(3), 173\u2013189"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to Algorithms (3rd ed.). MIT Press."}),"\n",(0,t.jsx)(n.li,{children:"Silberschatz, A., Korth, H. F., & Sudarshan, S. (2020). Database System Concepts (7th ed.). McGraw-Hill Education."}),"\n",(0,t.jsxs)(n.li,{children:["GeeksforGeeks. (n.d.). ",(0,t.jsx)(n.a,{href:"https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/",children:"B-Trees."})]}),"\n"]})]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>d});var i=r(6540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}},9365:(e,n,r)=>{r.d(n,{A:()=>o});r(6540);var i=r(4164);const t={tabItem:"tabItem_Ymn6"};var s=r(4848);function o({children:e,hidden:n,className:r}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,i.A)(t.tabItem,r),hidden:n,children:e})}}}]);